from typing import Optional, List, Dict
from dataclasses import dataclass

# from soupsieve import match

from ast_node import *
from lexer import *
import string

from parser import Parser

r"""
This is the Matcher Module.


The Matcher module is responsible for taking the Abstract Syntax Tree (AST) generated by the parser and using it to match input strings against the defined regular expressions. It traverses the AST nodes and applies the corresponding matching logic for each node type.

For Detailed Documentation of MAtcher ,why we need it , how it works please refer to main.py file docs.
"""


@dataclass
class Match:
    r"""
    This match class will represent a successful match result. It will contain things like start and end indices/positions of the match in the input string, the matched substring, and any captured groups if applicable.
    """

    start: int
    end: int
    text: str
    groups: Dict[int, Optional[str]]  # group number to matched text mapping

    r""" 
    what are Groups? well groups are just the capturing groups in th Regex patter n for ex: "(?:\d{3})-(\d{4})-\1" in this the (\d{4}) is a capturing group and \1 refers to the same group again. and this what we have captured so we have to store it in a map or a dictionary that looks some thing like this {1: "1234"} where 1 is the group number and "1234" is the matched text for that group.
    This is useful when we want to extract specific parts of the matched string based on the regex pattern. and aslo in backrefernces.
    """

    def group(self, n: int = 0) -> Optional[str]:
        r"""
        This function is the convenience function to get the captured group by its number.
        """

        if n == 0:
            return self.text
        return self.groups.get(n, None)


# matcher = Matcher(...)
# matcher.match("")
# matcher.match("")


class Matcher:
    def __init__(self, ast: ASTNode, flags: Optional[Dict[str, bool]] = None):
        self.ast = ast
        # self.flags = flags if flags is not None else {}
        self.flags = flags or {}

        # Setting up flags

        r"""
        The Flags are used to modify the behavior of the regex matching. for ex: ignorecase flag will make the matching case insensitive,multiline will make the ^ and $ to match the start and end of each line instead of the whole string and dotall will make the . to match new line characters as well.
        """
        self.ignore_case = self.flags.get("ignorecase", False)

        self.multiline = self.flags.get("multiline", False)

        self.dotall = self.flags.get("dotall", False)

        # State during matching

        r"""
        State during matching will keep track of the current position in the input string, the matched text so far, the length of the matched text, and any captured groups.
        """

        self.text = ""
        self.length = 0
        self.captures: Dict[int, Optional[str]] = {}

        self._init_char_classes()

    def _init_char_classes(self):
        # self.char_classes = {
        #     "digit": lambda c: c.isdigit(),
        #     "word": lambda c: c.isalnum() or c == "_",
        #     "space": lambda c: c.isspace()
        # }
        self.digit_chars = set("0123456789")
        self.word_chars = set(string.ascii_letters + string.digits + "_")
        self.whitespace_chars = set(" \t\n\r\f\v")

    def match(self, text: str, start: int = 0) -> Optional[Match]:
        r"""
        This is the main match function that will attempt to match the input text against the regex pattern represented by the AST. the function will have the text as an string which is to be matched and the start position from where the matching should begin.
        """

        self.text = text
        self.length = len(text)
        self.captures = {}

        r""" 
            why we are initializing the captures to empty dict? because we want to start fresh for each match attempt and we don't want to carry over any previous captures from previous match attempts.because let's say wh do some initial matching 
            # matcher = Matcher(...) we intialize the matcher with some ast
            # matcher.match("") --matched some text here were thing get's interesting and it's that when we again
            # matcher.match("") call the match funtion here it will only return the match res of the previous matchattempt if we don't reset the state of the matcher before each match attempt. So to avoid that we resetthe state of the matcher before each match attempt. and that is why we have made the captures to emptydict before each match attempt.
            """

        end_pos = self._match_node(self.ast, start)

        if end_pos is not None:
            return Match(
                start=start,
                end=end_pos,
                text=text[start:end_pos],
                groups=self.captures.copy(),
            )

        return None

    def search(self, text: str) -> Optional[Match]:
        self.text = text
        self.length = len(text)

        for start in range(len(text) + 1):
            self.captures = {}
            end_pos = self._match_node(self.ast, start)

            if end_pos is not None:
                return Match(
                    start=start,
                    end=end_pos,
                    text=text[start:end_pos],
                    groups=self.captures.copy(),
                )

        return None

    def findall(self, text: str) -> List[Match]:
        self.text = text
        self.length = len(text)
        matches = []
        pos = 0

        while pos <= len(text):
            self.captures = {}
            end_pos = self._match_node(self.ast, pos)

            if end_pos is not None:
                match = Match(
                    start=pos,
                    end=end_pos,
                    text=text[pos:end_pos],
                    groups=self.captures.copy(),
                )
                matches.append(match)

                pos = end_pos if end_pos > pos else pos + 1
            else:
                pos += 1

        return matches

    def _match_node(self, node: ASTNode, pos: int) -> Optional[int]:
        r"""
        This is the internal function that will recursively match the AST nodes against the input text starting from the given position. it will return the new position after matching if successful or None if the match fails.
        """

        if isinstance(node, CharNode):
            return self._match_char(node, pos)

        elif isinstance(node, DotNode):
            return self._match_dot(node, pos)

        elif isinstance(node, CharClassNode):
            return self._match_char_class(node, pos)

        elif isinstance(node, PredefinedClassNode):
            return self._match_predefined_class(node, pos)

        elif isinstance(node, QuantifierNode):
            return self._match_quantifier(node, pos)

        elif isinstance(node, ConcatNode):
            return self._match_concat(node, pos)

        elif isinstance(node, AlternationNode):
            return self._match_alternation(node, pos)

        elif isinstance(node, GroupNode):
            return self._match_group(node, pos)

        elif isinstance(node, NonCapturingGroupNode):
            return self._match_node(node.child, pos)

        elif isinstance(node, BackreferenceNode):
            return self._match_backreference(node, pos)

        elif isinstance(node, AnchorNode):
            return self._match_anchor(node, pos)

        elif isinstance(node, LookaheadNode):
            return self._match_lookahead(node, pos)

        elif isinstance(node, LookbehindNode):
            return self._match_lookbehind(node, pos)

        else:
            raise ValueError(f"Unknown node type: {type(node)}")

    def _match_char(self, node: CharNode, pos: int) -> Optional[int]:
        r"""
        This function will match a single character node against the input text at the given position.
        """

        # if pos >= self.length:
        #     return None

        # text_char = self.text[pos]

        # pattern_char = node.char

        # if self.ignore_case:
        #     # text_char = text_char.lower()
        #     # pattern_char = pattern_char.lower()

        #     # if text_char.lower() == pattern_char.lower():
        #     #     return pos + 1
        #     # else:
        #     #     return None

        #     if text_char == pattern_char:
        #         return pos + 1

        # return None

        if pos >= self.length:
            return None

        text_char = self.text[pos]
        pattern_char = node.char

        if self.ignore_case:
            text_char = text_char.lower()
            pattern_char = pattern_char.lower()

        if text_char == pattern_char:
            return pos + 1

        return None

    def _match_dot(self, node: DotNode, pos: int) -> Optional[int]:
        r"""
        This function will match a dot node against the input text at the given position.
        The dot matches any character except a newline unless the dotall flag is set.
        """

        if pos >= self.length:
            return None

        char = self.text[pos]

        if char == "\n" and not self.dotall:
            return None

        return pos + 1

    def _match_char_class(self, node: CharClassNode, pos: int) -> Optional[int]:
        r"""
        This function will match a character class node against the input text at the given position.
        """

        if pos >= self.length:
            return None

        char = self.text[pos]
        chars = node.chars
        # match = char in chars

        # if node.negated:
        #     match = not match

        # if match:
        #     return pos + 1

        # return None

        if self.ignore_case:
            char = char.lower()
            chars = set(c.lower() for c in chars)

        in_class = char in chars

        if in_class != node.negated:
            return pos + 1

        return None

    def _match_predefined_class(
        self, node: PredefinedClassNode, pos: int
    ) -> Optional[int]:
        r"""
        This function will match a predefined character class node against the input text at the given position.

        """

        if pos >= self.length:
            return None

        char = self.text[pos]
        # class_type = node.class_type

        # match = False

        # if class_type == r"\d":
        #     match = char.isdigit()
        # elif class_type == r"\D":
        #     match = not char.isdigit()
        # elif class_type == r"\w":
        #     match = char.isalnum() or char == "_"
        # elif class_type == r"\W":
        #     match = not (char.isalnum() or char == "_")
        # elif class_type == r"\s":
        #     match = char.isspace()
        # elif class_type == r"\S":
        #     match = not char.isspace()

        # if match:
        #     return pos + 1

        # return None

        r""" 
        The Difference between the above commented code and the below code is that in the above code we are using the built-in string methods like isdigit(), isalnum(), isspace() to check if the character belongs to the predefined class or not. but in the below code we are using our own predefined character sets like self.digit_chars, self.word_chars, self.whitespace_chars to check if the character belongs to the predefined class or not. This approach is more efficient as it avoids multiple function calls and uses set membership checking which is generally faster. 
        """

        matched = False

        if node.class_type == "d":
            matched = char in self.digit_chars

        elif node.class_type == "D":
            matched = char not in self.digit_chars

        elif node.class_type == "w":
            matched = char in self.word_chars

        elif node.class_type == "W":
            matched = char not in self.word_chars

        elif node.class_type == "s":
            matched = char in self.whitespace_chars

        elif node.class_type == "S":
            matched = char not in self.whitespace_chars

        if matched:
            return pos + 1

        return None

    def _match_quantifier(self, node: QuantifierNode, pos: int) -> Optional[int]:
        r"""
        This function will match a quantifier node against the input text at the given position.

        Intuition: the quantifier node means that total how many time some should repeat the child node. so there are 2 ways we can solve it either greedily or lazily.In greedy approach we try to match as many times as possible and then backtrack if needed. In lazy approach we try to match as few times as possible and then try to match more if needed.

        Example: Pattern as [a-z]* on text "aaa" to pos 0:
        1.Iteration 1: match 'a' -> next_pos = 1 -> , count = 1, matches = [1]
        2.Iteration 2: match 'a' -> next_pos = 2 -> , count = 2, matches = [1, 2]
        3.Iteration 3: match 'a' -> next_pos = 3 -> , count = 3, matches = [1, 2, 3]
        4.Iteration 4: match 'a' -> next_pos = None fails cuz out of range -> break
        """

        matches = []

        current_pos = pos
        count = 0
        while True:
            if node.max_count is not None and count >= node.max_count:
                break

            next_pos = self._match_node(node.child, current_pos)

            if next_pos is None:
                break

            count += 1
            current_pos = next_pos
            matches.append(next_pos)

        valid_matches = [pos] if node.min_count == 0 else []
        valid_matches.extend(
            [m for i, m in enumerate(matches, 1) if i >= node.min_count]
        )

        if not valid_matches:
            return None

        if node.greedy:
            return valid_matches[-1]
        else:
            # if not node.greedy:
            return valid_matches[0]

        r""" 
        Lazy matching:
        What is lazy matching? Lazy matching is when we try to match as few times as possible and then try to match more if needed. so in the above code we are trying to match the child node as few times as possible and then try to match more if needed. so we are iterating over the valid matches and trying to match the node after the quantifier for each valid match. if we find a match we return the new position after matching. if we don't find any match we rerurn node.
        
        What is greedy matching? Greedy matching is when we try to match as many times as possible and then backtrack if needed. so in the above code we are trying to match the child node as many times as possible and then backtrack if needed. so we are taking the last valid match and trying to match the node after the quantifier for that valid match. if we find a match we return the new position after matching. if we don't find any match we return None.
        """

        # return None

    def _match_concat(self, node: ConcatNode, pos: int) -> Optional[int]:
        r"""
        This function will match a concatenation node against the input text at the given position.
        """

        if not node.children:
            return pos

        return self._match_concat_recursive(node.children, 0, pos)

    def _match_concat_recursive(
        self, children: List[ASTNode], index: int, pos: int
    ) -> Optional[int]:
        r"""
        This is a helper function to recursively match the concatenation children.
        """

        if index >= len(children):
            return pos

        r"""a*b -> aaab how will we match this?
        1. Match 'a' with 'a' -> next_pos = 1
        2. Match 'a' with 'a' -> next_pos = 2
        3. Match 'a' with 'a' -> next_pos = 3
        the list will be like this [1,2,3] => similar to the quantifier matching
        4. Now we have matched all 'a's now we need to match 'b' with 'b'
        5. Match 'b' with 'b' -> next_pos = 4  
        
        """

        child = children[index]

        if isinstance(child, QuantifierNode):
            # Handle quantifier nodes separately
            current_pos = pos
            matches = []

            count = 0
            while True:
                if child.max_count is not None and count >= child.max_count:
                    break

                next_pos = self._match_node(child.child, current_pos)

                if next_pos is None:
                    break

                count += 1
                current_pos = next_pos
                matches.append(next_pos)

            valid_matches = [pos] if child.min_count == 0 else []
            valid_matches.extend(
                [m for i, m in enumerate(matches, 1) if i >= child.min_count]
            )

            if not valid_matches:
                return None

            # for match_pos in (
            #     reversed(valid_matches)
            #     if child.greedy
            #     else valid_matches
            # ):
            #     result_pos = self._match_concat_recursive(
            #         children, index + 1, match_pos
            #     )
            #     if result_pos is not None:
            #         return result_pos

            # return None

            if child.greedy:
                valid_matches.reverse()

            for match_end in valid_matches:
                result = self._match_concat_recursive(children, index + 1, match_end)

                if result is not None:
                    return result

            return None

        else:
            next_pos = self._match_node(child, pos)

            if next_pos is None:
                return None

            return self._match_concat_recursive(children, index + 1, next_pos)

    def _match_alternation(self, node: AlternationNode, pos: int) -> Optional[int]:
        r"""
        This function will match an alternation node agasinst the input text at the given position
        """

        for alt in node.alternatives:
            end_pos = self._match_node(alt, pos)

            if end_pos is not None:
                return end_pos

        return None

    def _match_group(self, node: GroupNode, pos: int) -> Optional[int]:
        r"""
        This function will match a capturing group node against the input text at the given position.
        """

        # start_pos = pos

        # end_pos = self._match_node(node.child, pos)

        # if end_pos is not None:
        #     # Capture the matched text for the group
        #     matched_text = self.text[start_pos:end_pos]
        #     self.captures[node.group_number] = matched_text
        #     return end_pos

        # return None

        old_capture = self.captures.get(node.group_number)

        end_pos = self._match_node(node.child, pos)

        if end_pos is not None:
            self.captures[node.group_number] = self.text[pos:end_pos]

            return end_pos

        else:
            if old_capture is not None:
                self.captures[node.group_number] = old_capture

            elif node.group_number in self.captures:
                del self.captures[node.group_number]

            return None

    def _match_backreference(self, node: BackreferenceNode, pos: int) -> Optional[int]:
        r"""
        This function will return the Backreference the of the node tree.
        """

        captured = self.captures.get(node.group_number)

        if captured is None:
            return None

        end_pos = pos + len(captured)

        if end_pos > self.length:
            return None

        text_slice = self.text[pos:end_pos]

        if self.ignore_case:
            if text_slice.lower() == captured.lower():
                return end_pos

        else:
            if text_slice == captured:
                return end_pos

        return None

    def _match_anchor(self, node: AnchorNode, pos: int) -> Optional[int]:
        if node.anchor_type == "^":
            if pos == 0:
                return pos

            if self.multiline and pos > 0 and self.text[pos - 1] == "\n":
                return pos

            return None

        elif node.anchor_type == "$":
            if pos == self.length:
                return pos

            if self.multiline and pos < self.length and self.text[pos] == "\n":
                return pos

            return None

        elif node.anchor_type == "b":
            before_is_word = pos > 0 and self.text[pos - 1] in self.word_chars
            after_is_word = pos < self.length and self.text[pos] in self.word_chars

            if before_is_word != after_is_word:
                return pos

            return None

        elif node.anchor_type == "B":
            before_is_word = pos > 0 and self.text[pos - 1] in self.word_chars
            after_is_word = pos < self.length and self.text[pos] in self.word_chars

            if before_is_word == after_is_word:
                return pos

            return None

        return None

        r"""" 
        
            
        """

    def _match_lookahead(self, node: LookaheadNode, pos: int) -> Optional[int]:
        r"""
        The look ahead function is going to look at the next character without moving to the next character so it need to traverse ahead
        """

        end_pos = self._match_node(node.child, pos)

        matched = end_pos is not None

        if matched == node.positive:
            return pos

        return None

    def _match_lookbehind(self, node: LookbehindNode, pos: int) -> Optional[int]:
        r"""
        Lookbehind is a bit tricky because it's same as look ahead but only in reverse like upside-down/mirror /reflection it is going to traverse in reverse but how ?

        Note: some regex only allow to look behind only by a fixed length but as for our case we can look behind the entire pattern string.

        """

        found_match = False

        for start in range(pos, -1, -1):
            end_pos = self._match_node(node.child, start)

            if end_pos == pos:
                found_match = True
                break

        if found_match == node.positive:
            return pos

        return None


# lexer = Lexer(r"(ab*c|d)")
lexer = Lexer(r"hello$")
tokens = lexer.tokenize()
parse = Parser(tokens)
ast = parse.parse()
matcher = Matcher(ast)
# print(matcher.match("abbc"))

# print(matcher.match("world hello"))
print(matcher.match("world hello", 6))

r""" 



"""
